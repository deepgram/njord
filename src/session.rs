use anyhow::Result;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::providers::Message;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NameSource {
    UserProvided,    // User explicitly named it with /chat save
    AutoGenerated,   // Created by /chat auto-rename
    Timestamp,       // Auto-generated timestamp from auto-save
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatSession {
    pub id: Uuid,
    pub name: Option<String>,
    #[serde(default)]
    pub name_source: Option<NameSource>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub messages: Vec<NumberedMessage>,
    pub current_model: String,
    pub current_provider: Option<String>,
    pub temperature: f32,
    pub max_tokens: u32,
    pub thinking_budget: u32,
    pub system_prompt: Option<String>,
    pub thinking_enabled: bool,
    #[serde(default)]
    pub has_llm_interaction: bool,
    #[serde(default)]
    pub variable_bindings: std::collections::HashMap<String, String>, // filename -> variable_name
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NumberedMessage {
    pub number: usize,
    pub message: Message,
    pub timestamp: DateTime<Utc>,
    pub code_blocks: Vec<CodeBlock>,
    pub provider: Option<String>,
    pub model: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeBlock {
    pub number: usize,
    pub language: Option<String>,
    pub content: String,
}

impl ChatSession {
    pub fn new(model: String, temperature: f32, max_tokens: u32, thinking_budget: u32) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            name: None,
            name_source: None,
            created_at: now,
            updated_at: now,
            messages: Vec::new(),
            current_model: model,
            current_provider: None,
            temperature,
            max_tokens,
            thinking_budget,
            system_prompt: None,
            thinking_enabled: false,
            has_llm_interaction: false,
            variable_bindings: std::collections::HashMap::new(),
        }
    }
    
    pub fn add_message(&mut self, message: Message) -> usize {
        let number = self.messages.len() + 1;
        let code_blocks = self.extract_code_blocks(&message.content);
        
        self.messages.push(NumberedMessage {
            number,
            message,
            timestamp: Utc::now(),
            code_blocks,
            provider: None,
            model: None,
        });
        
        self.updated_at = Utc::now();
        number
    }
    
    pub fn add_message_with_metadata(&mut self, message: Message, provider: Option<String>, model: Option<String>) -> usize {
        let number = self.messages.len() + 1;
        let code_blocks = self.extract_code_blocks(&message.content);
        
        self.messages.push(NumberedMessage {
            number,
            message,
            timestamp: Utc::now(),
            code_blocks,
            provider,
            model,
        });
        
        self.updated_at = Utc::now();
        number
    }
    
    fn extract_code_blocks(&self, content: &str) -> Vec<CodeBlock> {
        let mut code_blocks = Vec::new();
        let mut block_number = 1;
        
        // Find all code blocks using regex with DOTALL flag for multiline matching
        let code_block_regex = regex::Regex::new(r"(?s)```(\w+)?\n(.*?)\n```").unwrap();
        
        for captures in code_block_regex.captures_iter(content) {
            let language = captures.get(1).map(|m| m.as_str().to_string());
            let code_content = captures.get(2).map(|m| m.as_str().to_string()).unwrap_or_default();
            
            if !code_content.trim().is_empty() {
                code_blocks.push(CodeBlock {
                    number: block_number,
                    language,
                    content: code_content,
                });
                block_number += 1;
            }
        }
        
        code_blocks
    }
    
    pub fn undo(&mut self, count: usize) -> Result<Option<String>> {
        if self.messages.is_empty() {
            return Err(anyhow::anyhow!("No messages to undo"));
        }
        
        let mut agent_responses_removed = 0;
        let mut last_user_message = None;
        
        // Work backwards through messages
        while agent_responses_removed < count && !self.messages.is_empty() {
            let last_message = self.messages.last().unwrap();
            
            if last_message.message.role == "assistant" {
                // Remove the assistant message
                self.messages.pop();
                agent_responses_removed += 1;
                
                // Look for the preceding user message and remove it too
                if let Some(prev_message) = self.messages.last() {
                    if prev_message.message.role == "user" {
                        last_user_message = Some(prev_message.message.content.clone());
                        self.messages.pop();
                    }
                }
            } else if last_message.message.role == "user" {
                // If we end on a user message, save it and remove it
                last_user_message = Some(last_message.message.content.clone());
                self.messages.pop();
            } else {
                // System message or other - just remove
                self.messages.pop();
            }
        }
        
        if agent_responses_removed == 0 {
            return Err(anyhow::anyhow!("No agent responses found to undo"));
        }
        
        self.updated_at = Utc::now();
        Ok(last_user_message)
    }
    
    pub fn goto(&mut self, message_number: usize) -> Result<()> {
        if message_number == 0 || message_number > self.messages.len() {
            return Err(anyhow::anyhow!("Invalid message number: {}", message_number));
        }
        
        self.messages.truncate(message_number);
        self.updated_at = Utc::now();
        Ok(())
    }
    
    pub fn mark_llm_interaction(&mut self) {
        self.has_llm_interaction = true;
    }
    
    pub fn should_auto_save(&self) -> bool {
        self.has_llm_interaction && !self.messages.is_empty()
    }
    
    
    pub fn generate_auto_name(&self) -> String {
        self.created_at.format("%Y-%m-%d_%H:%M:%S").to_string()
    }
    
    pub fn create_copy(&self) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            name: None,
            name_source: None, // Reset for new copy
            created_at: now,
            updated_at: now,
            messages: self.messages.clone(),
            current_model: self.current_model.clone(),
            current_provider: self.current_provider.clone(),
            temperature: self.temperature,
            max_tokens: self.max_tokens,
            thinking_budget: self.thinking_budget,
            system_prompt: self.system_prompt.clone(),
            thinking_enabled: self.thinking_enabled,
            has_llm_interaction: false, // Reset for new copy
            variable_bindings: self.variable_bindings.clone(), // Copy variable bindings
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::providers::Message;

    #[test]
    fn test_new_session() {
        let session = ChatSession::new(
            "gpt-4".to_string(),
            0.7,
            1000,
            5000
        );
        
        assert_eq!(session.current_model, "gpt-4");
        assert_eq!(session.temperature, 0.7);
        assert_eq!(session.max_tokens, 1000);
        assert_eq!(session.thinking_budget, 5000);
        assert!(session.messages.is_empty());
        assert!(!session.has_llm_interaction);
        assert!(!session.thinking_enabled);
        assert!(session.name.is_none());
    }

    #[test]
    fn test_add_message() {
        let mut session = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        
        let message = Message {
            role: "user".to_string(),
            content: "Hello, world!".to_string(),
        };
        
        let number = session.add_message(message.clone());
        assert_eq!(number, 1);
        assert_eq!(session.messages.len(), 1);
        assert_eq!(session.messages[0].number, 1);
        assert_eq!(session.messages[0].message.content, "Hello, world!");
        assert_eq!(session.messages[0].message.role, "user");
    }

    #[test]
    fn test_add_message_with_metadata() {
        let mut session = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        
        let message = Message {
            role: "assistant".to_string(),
            content: "Hello back!".to_string(),
        };
        
        let number = session.add_message_with_metadata(
            message,
            Some("openai".to_string()),
            Some("gpt-4".to_string())
        );
        
        assert_eq!(number, 1);
        assert_eq!(session.messages[0].provider, Some("openai".to_string()));
        assert_eq!(session.messages[0].model, Some("gpt-4".to_string()));
    }

    #[test]
    fn test_code_block_extraction() {
        let mut session = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        
        let message = Message {
            role: "assistant".to_string(),
            content: "Here's some code:\n\n```python\nprint('hello')\n```\n\nAnd more:\n\n```rust\nfn main() {}\n```".to_string(),
        };
        
        session.add_message(message);
        
        assert_eq!(session.messages[0].code_blocks.len(), 2);
        
        let first_block = &session.messages[0].code_blocks[0];
        assert_eq!(first_block.number, 1);
        assert_eq!(first_block.language, Some("python".to_string()));
        assert_eq!(first_block.content, "print('hello')");
        
        let second_block = &session.messages[0].code_blocks[1];
        assert_eq!(second_block.number, 2);
        assert_eq!(second_block.language, Some("rust".to_string()));
        assert_eq!(second_block.content, "fn main() {}");
    }

    #[test]
    fn test_code_block_extraction_no_language() {
        let mut session = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        
        let message = Message {
            role: "assistant".to_string(),
            content: "```\nsome code\n```".to_string(),
        };
        
        session.add_message(message);
        
        assert_eq!(session.messages[0].code_blocks.len(), 1);
        let block = &session.messages[0].code_blocks[0];
        assert_eq!(block.language, None);
        assert_eq!(block.content, "some code");
    }

    #[test]
    fn test_undo_single_message() {
        let mut session = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        
        // Add user message
        let user_msg = Message {
            role: "user".to_string(),
            content: "Hello".to_string(),
        };
        session.add_message(user_msg);
        
        // Add assistant message
        let assistant_msg = Message {
            role: "assistant".to_string(),
            content: "Hi there!".to_string(),
        };
        session.add_message(assistant_msg);
        
        assert_eq!(session.messages.len(), 2);
        
        // Undo should remove assistant message and return user message
        let result = session.undo(1).unwrap();
        assert_eq!(session.messages.len(), 0);
        assert_eq!(result, Some("Hello".to_string()));
    }

    #[test]
    fn test_undo_multiple_messages() {
        let mut session = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        
        // Add multiple exchanges
        session.add_message(Message { role: "user".to_string(), content: "First".to_string() });
        session.add_message(Message { role: "assistant".to_string(), content: "Response 1".to_string() });
        session.add_message(Message { role: "user".to_string(), content: "Second".to_string() });
        session.add_message(Message { role: "assistant".to_string(), content: "Response 2".to_string() });
        
        assert_eq!(session.messages.len(), 4);
        
        // Undo 2 assistant responses - this should remove both assistant responses
        // and their corresponding user messages, returning the last user message
        let result = session.undo(2).unwrap();
        assert_eq!(session.messages.len(), 0);
        // The undo logic returns the last user message that was removed
        assert_eq!(result, Some("First".to_string()));
    }

    #[test]
    fn test_goto() {
        let mut session = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        
        // Add several messages
        for i in 1..=5 {
            session.add_message(Message {
                role: "user".to_string(),
                content: format!("Message {}", i),
            });
        }
        
        assert_eq!(session.messages.len(), 5);
        
        // Go to message 3
        session.goto(3).unwrap();
        assert_eq!(session.messages.len(), 3);
        assert_eq!(session.messages[2].message.content, "Message 3");
    }

    #[test]
    fn test_goto_invalid() {
        let mut session = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        
        session.add_message(Message {
            role: "user".to_string(),
            content: "Only message".to_string(),
        });
        
        // Test invalid message numbers
        assert!(session.goto(0).is_err());
        assert!(session.goto(2).is_err());
    }


    #[test]
    fn test_should_auto_save() {
        let mut session = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        
        // Empty session should not auto-save
        assert!(!session.should_auto_save());
        
        // Session with messages but no LLM interaction should not auto-save
        session.add_message(Message { role: "user".to_string(), content: "Hello".to_string() });
        assert!(!session.should_auto_save());
        
        // Session with LLM interaction should auto-save
        session.mark_llm_interaction();
        assert!(session.should_auto_save());
    }

    #[test]
    fn test_generate_auto_name() {
        let session = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        let auto_name = session.generate_auto_name();
        
        // Should be in format YYYY-MM-DD_HH:MM:SS
        assert!(auto_name.contains("_"));
        assert!(auto_name.contains("-"));
        assert!(auto_name.contains(":"));
    }

    #[test]
    fn test_create_copy() {
        let mut original = ChatSession::new("gpt-4".to_string(), 0.7, 1000, 5000);
        original.name = Some("original".to_string());
        original.mark_llm_interaction();
        original.add_message(Message { role: "user".to_string(), content: "Test".to_string() });
        
        let copy = original.create_copy();
        
        // Copy should have different ID and no name
        assert_ne!(copy.id, original.id);
        assert!(copy.name.is_none());
        assert!(!copy.has_llm_interaction);
        
        // But same content and settings
        assert_eq!(copy.messages.len(), original.messages.len());
        assert_eq!(copy.current_model, original.current_model);
        assert_eq!(copy.temperature, original.temperature);
        assert_eq!(copy.messages[0].message.content, "Test");
    }
}
